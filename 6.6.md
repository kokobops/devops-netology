# Домашнее задание к лекции - 6.6

## Задача 1.

* Напишите список операций, которые вы будете производить для остановки запроса пользователя

Сначала ищем opid операции

```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 }
   }
)
```
Далее завершаем операцию в соответствии с идентификатором операции

```
db.killOp(opid)
```

* Предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Мониторниг

Логирование долгих запросов

```
db.setProfilingLevel(1, 50)
```
1 - level
50 - милисекунды

Далее оптимизация

## Задача 2.

UPD:

Возможно проблема заключается в том, что у Redis закончилась память.

В [статье](https://redis.io/docs/getting-started/faq/) гворится, что Redis имеет встроенную защиту, позволяющую пользователям устанавливать максимальное ограничение на использование памяти, используя maxmemory параметр в файле конфигурации,
чтобы установить ограничение на объем памяти, который может использовать Redis. Если этот предел будет достигнут, Redis начнет отвечать ошибкой на команды записи (но продолжит принимать команды только для чтения).

В [статье](https://redis.io/docs/manual/replication/) говорится, что по умолчанию реплика будет игнорироваться maxmemory(если только она не будет повышена до главной после отработки отказа или вручную).
Это означает, что вытеснение ключей будет выполняться мастером, отправляющим команды DEL на реплику по мере вытеснения ключей на стороне мастера. ....


Поскольку реплика по умолчанию не вытесняется, она может в конечном итоге использовать больше памяти,
чем установлено через maxmemory(поскольку в реплике есть определенные буферы, которые могут быть больше, или структуры данных иногда могут занимать больше памяти и т. д.).

## Задача 3.

Это сообщение об ошибке может быть вызвано тремя вероятными причинами:

* запросы на миллионы строк, рекомендуется увеличение параметра net_read_timeout с 30 до 60 секунд
* клиент не успевает установить соединение, рекомендуется увеличить параметр connect_timeout value до 10 секунд
* значения BLOB превышают параметр max_allowed_packet

Какие пути решения данной проблемы вы можете предложить?

Нужно поиграться с этими тремя параметрами, выяснить какой или какие из них нужно увеличить.

## Задача 4.

Как вы думаете, что происходит?

Закончилась память. Когда у сервера или процесса заканчивается память, Linux предлагает 2 пути решения:
обрушить всю систему или завершить процесс (приложение), который съедает память. Лучше, конечно, завершить процесс и спасти ОС от аварийного завершения.
В двух словах, Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.

Как бы вы решили данную проблему?

UPD:

В Postgres необходимо настроить параметры, связанные с памятью:

max_connections

shared_buffer

work_mem

effective_cache_size

maintenance_work_mem

В [статье](https://habr.com/ru/company/southbridge/blog/464245/) на хабре описали такой вариант

Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту, и этим поведением управляет параметр ядра Linux. За это отвечает переменная vm.overcommit_memory.


Для нее можно указывать следующие значения:


0: ядро само решает, стоит ли резервировать слишком много памяти. Это значение по умолчанию в большинстве версий Linux.

1: ядро всегда будет резервировать лишнюю память. Это рискованно, ведь память может закончиться, потому что, скорее всего, однажды процессы затребуют положенное.

2: ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio.


В этом параметре вы указываете процент памяти, для которого допустимо избыточное резервирование. Если для него нет места, память не выделяется, в резервировании будет отказано.
Это самый безопасный вариант, рекомендованный для PostgreSQL. На OOM-Killer влияет еще один элемент — возможность подкачки, которой управляет переменная cat /proc/sys/vm/swappiness.
Эти значения указывают ядру, как обрабатывать подкачку страниц. Чем больше значение, тем меньше вероятности, что OOM завершит процесс, но из-за операций ввода-вывода это негативно сказывается на базе данных.
И наоборот — чем меньше значение, тем выше вероятность вмешательства OOM-Killer, но и производительность базы данных тоже выше.
Значение по умолчанию 60, но если вся база данных помещается в память, лучше установить значение 1.